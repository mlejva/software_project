- Using OpenCV to generate images
- Using with Python3
    - pip3 install opencv-python

Not useful anymore, moved entirely from C++ to Python
ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ
- Tutorial for using OpenCV on Mac: https://blogs.wcode.org/2014/10/howto-install-build-and-use-opencv-macosx-10-10/ with C++
    - /Applications/CMake.app/Contents/bin/cmake .
    - make
    - ./GenerateVideos


- Images
    - White background
    - Exactly one pixel is black
    - For the given video, black pixel is linearly moving along one of the axis
    - for example 100x100
    - That is 10k pixels
    - For the given black pixel position we need at least two 'free' pixels at a single direction to move the black pixel
    - This sequence creates a single video
    - That is 100*100*4 = 40k frames
    //- That is: 2*(m*(n-2)) + 2*((m-3)*n) = 38800 frames
    
- Videos
    - Videos are made as a sequence of images using ffmpeg
        - A single image with a given black pixel position is a single frame
    - NN gets a video as an input and processes every two frames, generating the third frame
    - Training: 60%
        - 24k frames
    - Cross validation: 20%
        - 8k frames
    - Testing: 20%
        - 8k frames










            Izoluje jeden cernych pixel, ale kazdy vystup size je stejny
            ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ
            batch_size = 5

            self.input_frames = tf.placeholder(tf.float32, [None, self.frame_height, self.frame_width, 2])            
            self.gold_output_frames = tf.placeholder(tf.float32, [None, self.frame_height, self.frame_width])            
        
            conv_layer1 = tf_layers.convolution2d(self.input_frames, 30, [5, 5], 2, padding="SAME", normalizer_fn=tf_layers.batch_norm)
            max_pool = tf.layers.max_pooling2d(conv_layer1, [20, 20], 2, padding="SAME")
            flattened = tf_layers.flatten(max_pool)                    
            output_layer = tf_layers.fully_connected(flattened, num_outputs=400, activation_fn=tf.sigmoid)
            self.predictions = output_layer            
            gold_output_flattened = tf_layers.flatten(self.gold_output_frames)                        
            self.loss = tf.losses.absolute_difference(gold_output_flattened, self.predictions)

